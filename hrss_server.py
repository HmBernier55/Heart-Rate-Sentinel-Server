"""Database format

pt_db = [
    {'patient_id': <int>,
    'attending_username': <string>,
    'patient_age': <int>,
    'heart_rate': [<int>],
    'heart_rate_timestamp': [<datetime object>]
    'status': <string>
    }
]

attending_db = [
    {'attending_username':<string>,
     'attending_email': <string>,
     'attending_phone': <string>
    }
]
"""

from flask import Flask, request, jsonify
from datetime import datetime
import re
import requests
import logging

app = Flask(__name__)

pt_db = []
att_db = []


@app.route('/', methods=['GET'])
def server_status():
    """GET route at home address to indicate server status.

    Route located at the server URL to indicate the status of the server.
    Useful in testing that the server is on before sending requests via a
    client.

    Returns:
        str: Message indicating the server is on
    """
    return "HRSS server is on"


def init_server():
    """Initializes the patient and attending databases in the HRSS server

    Adds some initial, hard-coded data to the patient and attending databases
    for testing purposes. Databases are cleared upon the start of this function
    to avoid issues when this function is called multiple times in the testing
    framework. This function also sets up the logging configuration for the
    HRSS server, specifying a logging file and the logging level at INFO to
    capture logs generated by the addition of new patients, new attendings, or
    tachycardic heart rate data.
    """
    pt_db.clear()
    att_db.clear()

    logging.basicConfig(filename='hrss_log.log', level=logging.INFO,
                        filemode='w')

    add_patient(1, 'Smith.J', 20)
    add_patient(2, 'Smith.J', 48)

    times = ['11/04/22 23:50:05', '11/04/22 23:55:05', '11/05/22 00:00:05',
             '11/05/22 00:05:05', '11/05/22 00:10:05', '11/05/22 00:15:05']
    dt_format = '%m/%d/%y %H:%M:%S'

    pt_db[0]['heart_rate'] = [60, 70, 80, 90, 100, 110]
    pt_db[0]['heart_rate_timestamp'] = [datetime.strptime(d_string, dt_format)
                                        for d_string in times]
    pt_db[0]['status'] = 'tachycardic'

    pt_db[1]['heart_rate'] = [65, 75, 85, 95]
    pt_db[1]['heart_rate_timestamp'] = [datetime.strptime(d_string, dt_format)
                                        for d_string in times[:4]]
    pt_db[1]['status'] = 'not tachycardic'

    add_attending('Smith.J', 'DrSmith@my_hospital.com', '919-555-1212')
    add_attending('Doe.J', 'DrDoe@my_hospital.com', '919-777-1313')


def add_patient(id, att_username, age):
    """Adds a patient to the patient database

    Adds a patient with an ID, attending username, and age as specified by the
    input function arguments to the patient database. The patient database is
    a list containing patients represented as dictionaries mapping string keys
    to values. Upon creation of a new patient, additional fields for heart rate
    data and the cardiac status of the patient are created for manipulation
    by functions that modify or add to patient values. An info message is
    added to the server log every time a new patient is added.

    Args:
        id (int): ID of the patient to add
        att_username (str): username of the attending physician for the
            to-be-added patient
        age (int): Age of the patient to add
    """
    new_pt = {'patient_id': id,
              'attending_username': att_username,
              'patient_age': age,
              'heart_rate': [],
              'heart_rate_timestamp': [],
              'status': ''}
    pt_db.append(new_pt)
    log_new_pt(id)


def add_attending(username, email, phone):
    """Adds an attending physician to the attending database

    Adds an attending with a username, email, and phone number as specified by
    the input function arguments to the attending database. The attending
    database is a list containing attendings represented as dictionaries
    mapping string keys to values. An info message is added to the server log
    every time a new patient is added.

    Args:
        username (str): username of to-be-added attending physician
        email (str): email of to-be-added attending physician
        phone (str): phone number of to-be-added attending physician
    """
    new_att = {'attending_username': username,
               'attending_email': email,
               'attending_phone': phone}
    att_db.append(new_att)
    log_new_att(username, email)


def log_new_pt(pt_id):
    """Logging function for new patient creation

    Adds an INFO-level message to the log file set in the logging configuration
    done in the init_server() function. Generates a message indicating that a
    new patient was added to the database with ID number of the newly-added
    patient.

    Args:
        pt_id (int): ID of the newly-added patient
    """
    logging.info(f'New patient registered to database with ID {pt_id}')


def log_new_att(att_username, att_email):
    """Logging function for new attending creation

    Adds an INFO-level message to the log file set in the logging configuration
    done in the init_server() function. Generates a message indicating that a
    new attending was added to the database with username and email of the
    newly-added attending physician.

    Args:
        att_username (_type_): _description_
        att_email (_type_): _description_
    """
    logging.info('New attending physician registered with username '
                 f'{att_username} and email {att_email}')

# ************************** Zac *********************************


@app.route('/api/new_patient', methods=['POST'])
def new_patient_handler():
    """Server route to add new patients to patient database

    POST request handler to receive patient data from a client, add patient
    to database if sent information has the correct format, and return a
    message and status code to the client indicating the status of the POST
    request. Expected data format is as follows:

    {
    "patient_id": <int> or <numeric str> (ID of patient to be added
        to database, ID must not already be in database),
    "attending_username": <str> (name of attending physican for this patient,
        attending physician must already be in attending database),
    "patient_age": <int> or <numeric str> (Age of patient)
    }

    Returns:
        (str, int): Message indicating success or failure (and why if failure)
            of server request and associated status code for request
    """
    in_data = request.get_json()
    message, status_code = add_new_patient_worker(in_data)
    return message, status_code


def add_new_patient_worker(in_data):
    """Implements '/api/new_patient' POST handler

    Called by '/api/new_patient' POST route to perform addition of patient to
    the patient database. Data collected by the POST handler is first validated
    to ensure the correct format of the data with a data validation function
    and then the data is added to the database for a single patient.

    Args:
        in_data (dict): Patient data gathered from the '/api/new_patient' POST
            handler with format described in the handler above. Data not
            adhering to this format will be rejected by the validation function
            with a status code of 400 and a message indicating why the
            rejection occurred.

    Returns:
        (str, int): Message indicating success or failure (and why if failure)
            of server request and associated status code for request
    """
    result = validate_new_patient(in_data)
    if result is not True:
        return result, 400

    add_patient(int(in_data['patient_id']),
                str(in_data['attending_username']),
                int(in_data['patient_age']))
    return 'Patient successfully added', 200


def validate_new_patient(in_data):
    """Validates format of '/api/new_patient' POST data

    Ensures that data sent from a client to the '/api/new_patient' POST route
    has the correct format to be added to the patient database. Data not
    adhering to the format defined below will be rejected by the validation
    function with a status code of 400 and a message indicating why the
    rejection occurred.

    Input data must:
        - be a dictionary
        - map key -> value:
            - 'patient_id' (<str>) -> <int/str>
            - 'attending usrename' (<str>) -> <str>
            - 'patient_age' (<str>) -> <int/str>
        - have an ID that is not already in the database
        - have an attending username of the format 'LastName.FirstInitial'
        - have the specified attending physician already registered in the
            attending database

    Args:
        in_data (dict): Patient data gathered from the '/api/new_patient' POST
            handler with format described in the handler above.

    Returns:
        str/boolean: Message indicating reason for POST data rejection or
            True if data has correct format
    """
    if type(in_data) is not dict:
        return 'POST data was not a dictionary'

    # check for correct keys and value types
    expected_keys = ['patient_id', 'attending_username', 'patient_age']
    expected_types = [[str, int], [str], [str, int]]
    for ex_key, ex_type in zip(expected_keys, expected_types):
        if ex_key not in in_data:
            return f'Key {ex_key} is missing from POST data'
        if type(in_data[ex_key]) not in ex_type:
            return f'Value of key {ex_key} is not of type(s) {ex_type}'

    # check that id and age are numeric strings if strings
    if type(in_data['patient_id']) == str:
        id_numeric = in_data['patient_id'].isnumeric()
        if not id_numeric:
            return 'Key patient_id must be an integer or numeric string'
    if type(in_data['patient_age']) == str:
        age_numeric = in_data['patient_age'].isnumeric()
        if not age_numeric:
            return 'Key patient_age must be an integer or numeric string'

    # check patient_id not already in database
    ids_present = []
    for pt in pt_db:
        ids_present.append(pt['patient_id'])
    if int(in_data['patient_id']) in ids_present:
        return f'Patient is already in database'

    # check that attending username is LastName.FirstInitial
    att = in_data['attending_username']
    period_count = att.count('.')
    if period_count != 1:
        return 'Key attending_username have format "LastName.FirstInitial"'
    [att_last, att_first] = att.split('.')
    if len(att_last) <= 0 or len(att_first) != 1:
        return 'Key attending_username have format "LastName.FirstInitial"'

    # check associated attending is in attending database
    att_present = []
    for ap in att_db:
        att_present.append(ap['attending_username'])
    if att not in att_present:
        return f'Attending physician {att} not present in physician database'

    return True


@app.route('/api/heart_rate', methods=['POST'])
def heart_rate_handler():
    """Server route to add heart rate data to a patient

    POST request handler to receive heart rate data from a client, add heart
    rate data to patient database if sent information has the correct format,
    and return a message and status code to the client indicating the status of
    the POST request. Expected data format is as follows:

    {
    "patient_id": <int> or <numeric str> (ID of patient int the patient
        database, ID must be associated with a patient in the database),
    "heart_rate": <int> or <numeric str> (single heart rate in bpm to be added
        to the patient in the database specified by the key patient_id)
    }

    Returns:
        (str, int): Message indicating success or failure (and why if failure)
            of server request and associated status code for request
    """
    in_data = request.get_json()
    message, status_code = heart_rate_worker(in_data)
    return message, status_code


def heart_rate_worker(in_data):
    """Implements '/api/heart_rate' POST handler

    Called by '/api/heart_rate' POST route to perform addition of a heart rate
    value to the heart rate measurements for a patient in the patient database.
    Data collected by the POST handler is first validated to ensure the correct
    format of the data with a data validation function and then the patient
    data is updated with the input heart rate data.

    Args:
        in_data (dict): Heart rate data gathered from the '/api/heart_rate'
            POST handler with format described in the handler above. Data not
            adhering to this format will be rejected by the validation function
            with a status code of 400 and a message indicating why the
            rejection occurred.

    Returns:
        (str, int): Message indicating success or failure (and why if failure)
            of server request and associated status code for request
    """
    result = validate_heart_rate(in_data)
    if result is not True:
        return result, 400

    email_sent = add_heart_rate(int(in_data['patient_id']),
                                int(in_data['heart_rate']))
    if email_sent:
        return_string = 'Heart rate data successfully added, tachycardic ' +\
                        'email alert sent to assigned physician'
        return return_string, 200

    return 'Heart rate data successfully added', 200


def validate_heart_rate(in_data):
    """Validates format of '/api/heart_rate' POST data

    Ensures that data sent from a client to the '/api/heart_rate' POST route
    has the correct format to be added to the patient database. Data not
    adhering to the format defined below will be rejected by the validation
    function with a status code of 400 and a message indicating why the
    rejection occurred.

    Input data must:
        - be a dictionary
        - map key -> value:
            - 'patient_id' (<str>) -> <int/str>
            - 'heart_rate' (<str>) -> <int/str>
        - have an ID that is already in the database

    Args:
        in_data (dict): Patient data gathered from the '/api/heart_rate' POST
            handler with format described in the handler above.

    Returns:
        str/boolean: Message indicating reason for POST data rejection or
            True if data has correct format
    """
    if type(in_data) is not dict:
        return 'POST data was not a dictionary'

    # check for correct keys and value types
    expected_keys = ['patient_id', 'heart_rate']
    expected_types = [[str, int], [str, int]]
    for ex_key, ex_type in zip(expected_keys, expected_types):
        if ex_key not in in_data:
            return f'Key {ex_key} is missing from POST data'
        if type(in_data[ex_key]) not in ex_type:
            return f'Value of key {ex_key} is not of type(s) {ex_type}'

    # check that id and age are numeric strings if strings
    if type(in_data['patient_id']) == str:
        id_numeric = in_data['patient_id'].isnumeric()
        if not id_numeric:
            return 'Key patient_id must be an integer or numeric string'
    if type(in_data['heart_rate']) == str:
        hr_numeric = in_data['heart_rate'].isnumeric()
        if not hr_numeric:
            return 'Key heart_rate must be an integer or numeric string'

    if not find_pt(int(in_data['patient_id'])):
        return f"ID {int(in_data['patient_id'])} not in patient database"

    return True


def add_heart_rate(pt_id, heart_rate):
    """Adds heart rate data to the patient specified by the input patient ID

    Updates the heart rate data for a patient in the patient database with
    the input heart rate. This function adds the heart rate value to a list of
    all previous heart rate measurements for the found patient. The current
    date and time are added to a list of heart rate timestamps associated with
    each heart rate in the heart rate measurement lists for a patient. The
    cardiac status of the patient (tachycardic or not tachycardic) is updated
    based on the heart rate when a new heart rate is added. If the heart rate
    is determiend to be tachycardic, an email is sent to the patient's
    assigned physician and an info log message is generated.

    Args:
        pt_id (int): ID number of a patient in database *Note: because this
            function is only called after heart rate POST data is validated,
            the patient ID is guaranteed to be in the patient database
        heart_rate (int): heart rate to add in bpm

    Returns:
        boolean: True if heart rate is tachycardic, False otherwise
    """
    pt = find_pt(pt_id)
    pt['heart_rate'].append(heart_rate)
    hr_timestamp = datetime.now()
    pt['heart_rate_timestamp'].append(hr_timestamp)

    if is_tachycardic(pt['patient_age'], heart_rate):
        pt['status'] = 'tachycardic'
        att = find_attending(pt['attending_username'])
        email_tachy_driver(att['attending_email'], pt_id, heart_rate,
                           hr_timestamp)
        log_tachycardic(pt_id, heart_rate, att['attending_email'])
        return True
    else:
        pt['status'] = 'not tachycardic'
        return False


def log_tachycardic(pt_id, heart_rate, att_email):
    """Logging function for tachycardic heart rates

    Adds an INFO-level message to the log file set in the logging configuration
    done in the init_server() function. Generates a message indicating that a
    tachycardic heart rate was added to a patient in the database, specifiying
    the patient's heart rate and ID, and that an email alert was sent to the
    attending physician for that patient.

    Args:
        pt_id (int): ID of tachycardic patient
        heart_rate (int): heart rate value in bpm determined to be tachycardic
        att_email (str: email of the attending physician for patient specified
            by the ID
    """
    logging.info(f'Tachycardic heart rate of {heart_rate} bpm detected in '
                 f'patient with ID {pt_id}. Sending alert to {att_email}')


def find_attending(att_username):
    """Finds the attending physician with the specified username

    Searches the attending physician database to return the information of the
    attending physician with the matching username.

    Args:
        att_username (str): username of the attending physician to serach by

    Returns:
        dict/boolean: dictionary containing all information from the database
            for the attending specified by the username if they exist in the
            database or False if the username is not in the attending database
    """
    for att in att_db:
        if att['attending_username'] == att_username:
            return att
    return False


def find_pt(pt_id):
    """Finds the patient with the specified patient ID

    Searches the patient database to return the information of the patient with
    the ID.

    Args:
        pt_id (int): ID of the patient to serach by

    Returns:
        dict/boolean: dictionary containing all information from the database
            for the patient specified by the ID if they exist in the
            database or False if the ID is not in the patient database
    """
    for pt in pt_db:
        if pt['patient_id'] == pt_id:
            return pt
    return False


def is_tachycardic(pt_age, heart_rate):
    """Determines if an input heart rate is tachycardic

    Uses information on tachycardic heart rates found at
    https://en.wikipedia.org/wiki/Tachycardia to determine if a heart rate
    value in bpm is tachycardic for the provided patient age.

    Args:
        pt_age (int): age of the patient
        heart_rate (int): heart rate in bpm

    Returns:
        boolean: True if the heart rate is tachycardic, False otherwise
    """
    if pt_age < 2:
        return heart_rate > 151
    elif pt_age < 4:
        return heart_rate > 137
    elif pt_age < 7:
        return heart_rate > 133
    elif pt_age < 11:
        return heart_rate > 130
    elif pt_age < 15:
        return heart_rate > 119
    else:
        return heart_rate > 100


def email_tachy_driver(to_email, pt_id, heart_rate, hr_datetime):
    """Driver function to send tachycardic email POST request to email server

    Calls multiple functions to send an email alert containing information on
    a patient's tachycardic heart rate to their assigned physician. First
    creates a dictionary to send as a request to the email server with the
    desired alert information. This format of this information is checked and
    then sent as a POST request to the email server if the information has the
    correct format.

    Email data created in this function has the following format:
    {
    "from_email": <str> (email which alert is sent from
        ('tachycardic-alert@hospital.com')),
    "to_email": <str> (email of attending physician to send alert to),
    "subject": <str> (subject of tachycardic alert email containing patient ID
        of patient with tachycardic heart rate),
    "content": <str> (content of tachycardic alert email containing patient ID
        heart rate value, and timestamp heart rate)
    }

    Args:
        to_email (str): email of the attending physician to send the email to
        pt_id (int): ID of patient with tachycardic heart rate
        heart_rate (int): tachycardic heart rate in bpm
        hr_datetime (datetime object): timestamp of tachycardic heart rate

    Returns:
        (str, int, dict): Message indicating success or failure (and why if
            failure) of email request, associated status code for request,
            and email data dictionary sent out for request (return mostly
            used for testing)
    """
    from_email = 'tachycardic-alert@hospital.com'
    email_sub = f'Patient {pt_id} tachycardic'
    email_content = f'Patient {pt_id} classified as tachycardic with heart ' +\
                    f'rate of {heart_rate} at {hr_datetime}'
    email_data = {'from_email': from_email,
                  'to_email': to_email,
                  'subject': email_sub,
                  'content': email_content}

    result = validate_email_data(email_data)
    if result is not True:
        return result, 400, email_data

    email_result, email_status = send_tachycardic_email(email_data)
    return email_result, email_status, email_data


def validate_email_data(email_data):
    """Validates format of POST data to be sent to email server

    Ensures that data sent as POST request to the email server has the correct
    format to send the email. Data not adhering to the format defined below
    will be rejected by the validation function with a status code of 400 and
    a message indicating why the rejection occurred.

    Input data must:
        - be a dictionary
        - map key -> value:
            - 'from_email' (<str>) -> <str>
            - 'to_email' (<str>) -> <str>
            - 'subject' (<str>) -> <str>
            - 'content' (<str>) -> <str>
        - contain emails with the correct format (<name>@<domain>.<suffix>)

    Args:
        email_data (dict): Email data created in the email_tachy_driver() to
        be sent as a POST request to the email server. Format of the email
        data is described in email_tachy_driver()

    Returns:
        str/boolean: Message indicating reason for POST data rejection or
            True if data has correct format
    """
    if type(email_data) is not dict:
        return 'POST data was not a dictionary'

    # check for correct keys and value types
    expected_keys = ['from_email', 'to_email', 'subject', 'content']
    expected_types = [[str], [str], [str], [str]]
    for ex_key, ex_type in zip(expected_keys, expected_types):
        if ex_key not in email_data:
            return f'Key {ex_key} is missing from POST data'
        if type(email_data[ex_key]) not in ex_type:
            return f'Value of key {ex_key} is not of type(s) {ex_type}'

    # check that both email addresses have correct format
    to_email_valid = check_email_format(email_data['to_email'])
    from_email_valid = check_email_format(email_data['from_email'])
    if not from_email_valid or not to_email_valid:
        return f'Emails must be of the form <name>@<domain>.<suffix>'

    return True


def check_email_format(email):
    """Checks that email string is of the form <name>@<domain>.<suffix>

    Uses regular expressions to check that an email string has the form
    <name>@<domain>.<suffix> i.e. email must have an @ symbol, period, and
    content in the <name>, <domain>, and <suffix> locations

    Args:
        email (str): email address

    Returns:
        boolean: True if email has valid format, False otherwise
    """
    regex_email = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9._%+-]+\.[A-Z|a-z]{2,}\b'
    if re.fullmatch(regex_email, email):
        return True
    return False


def send_tachycardic_email(email_data):
    """Sends tachycardic email data to the email server

    Sends the tachycardic email alert to the virtual machine hosting the email
    server at the URL below. The email data dictionary is sent as a POST
    request using the requests package.

    Args:
        email_data (dict): Email data created in the email_tachy_driver() to
        be sent as a POST request to the email server. Format of the email
        data is described in email_tachy_driver()

    Returns:
        (str, int): Message indicating success or failure (and why if
            failure) of email request, associated status code for request
    """
    email_url = 'http://vcm-7631.vm.duke.edu:5007/hrss/send_email'
    r_email = requests.post(email_url, json=email_data)
    return r_email.text, r_email.status_code


@app.route('/api/heart_rate/<patient_id>', methods=['GET'])
def get_pt_heart_rate_handler(patient_id):
    """Server route to get all heart rate measurements for a patient

    GET request handler to receive a patient ID from the variable address and
    either return a list of heart rate measurements for the patient if the
    request succeeds or a message explaining the failure if the request fails.
    The patient ID to receive the heart rates of is specified in the URL of the
    GET request.

    Args:
        patient_id (string): ID of the patient as a string as received from the
            string address of the GET request

    Returns:
        (str, int): list of heart rates as a JSON string or message indicating
            request failure, request status code
    """
    # patient id always comes in as string from URL
    pt_hr_result, status_code = get_pt_heart_rate_worker(patient_id)
    return jsonify(pt_hr_result), status_code


def get_pt_heart_rate_worker(pt_id):
    """Implements '/api/heart_rate/<patient_id>' GET handler

    Called by '/api/heart_rate/<patient_id>' GET route to get a list of all
    heart rate measurements for a patient in the patient database. Patient ID
    collected by the GET handler is first validated to ensure the correct
    format of the ID and that the ID exists in the database with a data
    validation function and then list of heart rates is extracted for that
    patient.

    Args:
        pt_id (str): ID of the patient as a string as received from the
            string address of the GET request

    Returns:
        (list/string, int): list of heart rates or message indicating
            request failure, request status code
    """
    result = validate_pt_id(pt_id)
    if result is not True:
        return result, 400

    pt = find_pt(int(pt_id))

    return pt['heart_rate'], 200


def validate_pt_id(pt_id):
    """Validates format of '/api/heart_rate/<patient_id>' GET patient ID

    Checks that the string patient ID received from the
    '/api/heart_rate/<patient_id>' GET handler is a numeric string (to be
    converted to an int to access the patient database) and that the integer
    ID exists for a patient in the database. Patient IDs not adhering to the
    this format will be rejected by this validation function with a status code
    of 400 and a message indicating why the rejection occurred.

    Args:
        pt_id (str): ID of the patient as a string as received from the
            string address of the GET request

    Returns:
        str/boolean: Message indicating reason for GET ID rejection or
            True if ID has correct format
    """
    if not pt_id.isnumeric():
        return 'Patient ID in request must be a numeric string'

    if not find_pt(int(pt_id)):
        return f'ID {pt_id} not in patient database'

    return True


@app.route('/api/heart_rate/average/<patient_id>', methods=['GET'])
def get_pt_avg_heart_rate_handler(patient_id):
    """Server route to get the average heart rate (as integer) for a patient

    GET request handler to receive a patient ID from the variable address and
    either return the average of all heart reate measurements for the patient
    as an integer if the request succeeds or a message explaining the failure
    if the request fails. The patient ID to receive the heart rates of is
    specified in the URL of the GET request.

    Args:
        patient_id (string): ID of the patient as a string as received from the
            string address of the GET request

    Returns:
        (str, int): integer average of heart rates as a JSON string or message
            indicating request failure, request status code
    """
    # patient id always comes in as string from URL
    avg_hr_result, status_code = get_avg_heart_rate_worker(patient_id)
    return jsonify(avg_hr_result), status_code


def get_avg_heart_rate_worker(pt_id):
    """Implements '/api/heart_rate/average/<patient_id>' GET handler

    Called by '/api/heart_rate/average/<patient_id>' GET route to get the
    integer average of all
    heart rate measurements for a patient in the patient database. Patient ID
    collected by the GET handler is first validated to ensure the correct
    format of the ID and that the ID exists in the database with a data
    validation function. Then the list of heart rates is extracted for that
    patient using the worker function for '/api/heart_rate/<patient_id>' and
    the average of that heart rate list is calculated as an integer.

    Args:
        pt_id (str): ID of the patient as a string as received from the
            string address of the GET request

    Returns:
        (int/string, int): integer average of heart rates or message indicating
            request failure, request status code
    """
    # worker for get pt heart rate route already validates id and gets list of
    # heart rates
    pt_hr_result, hr_code = get_pt_heart_rate_worker(pt_id)
    if hr_code != 200:
        return pt_hr_result, hr_code

    if len(pt_hr_result) == 0:
        return f'No heart rate measurements for patient {pt_id}', 400

    avg_hr = int_average(pt_hr_result)
    return avg_hr, 200


def int_average(in_list):
    """Calculates the average of a list of values as an integer

    Determines the average value of a list of numeric values by dividing the
    sum of the list by the length of the list. This calculated averaged is
    cast as an integer before being returned.

    Args:
        in_list (list of numeric types (int, float)): list of numbers to be
            averaged

    Returns:
        int: average of input list
    """
    avg = sum(in_list) / len(in_list)
    return int(avg)


# *****************************************************************
# *****************************************************************

# ************************** Hunter *********************************

@app.route('/api/new_attending', methods=['POST'])
def new_attending_handler():
    """Add a new attending to the database

    The function takes in a json dictionary from a POST request from
    a client, adds the new attending to the database on the server with
    the given url, and outputs a message either telling the client the
    attending was added successfully or something went wrong and explains
    the error. If there is an error a status code of 400 is output and if
    the attending was added successfully a status code of 200 is output.

    Format for input json dictionary:
    {
        "attending_username": <attending_username_string>
        "attending_email": <attending_email_string>
        "attending_phone": <attending_phone_string>
    }

    Args:
        (json dictionary): new attending dictionary with all strings

    Returns:
        string: a message saying the new attending was either added
            successfully or it failed and why
        string: status code either 200 for success or 400 for failure
    """
    in_data = request.get_json()
    message, status_code = new_attending_worker(in_data)
    return message, status_code


def new_attending_worker(in_data):
    """Driver function for the route /api/new_attending

    The function validates that the input json dictionary is of
    the correct format, keys, and values, adds the new attending
    to the database with the input json dictionary, and outputs a message
    of success or failure when adding the new attending and a status code.
    The function uses two other functions: validate_new_attending and
    add_attending.

    Args:
        in_data (json dictionary): contains attending username, attending
            email, and attending phone number; all strings

    Returns:
        string: message saying if the attending was added successfully
            or failed and why
        int: status code either a 200 for success or a 400 for a failure
    """
    result = validate_new_attending(in_data)
    if result is not True:
        return result, 400
    add_attending(in_data["attending_username"],
                  in_data["attending_email"],
                  in_data["attending_phone"])
    return "Attending successfully added", 200


def validate_new_attending(in_data):
    """Validates the input json dictionary

    The function takes in a json dictionary and runs a few tests
    on the values within it. The first one tests if the input is
    a dictionary. If its not the function returns 'POST data was not a
    dictionary'. The second one tests if the expected keys are all
    present i.e. attending_username, attending_email, and attending_phone.
    If they all aren't there, the function returns 'Key {} is missing from
    POST data' with the brackets filled in with the missing key. The third
    one tests if all the key's values are the correct data type. If they
    aren't, the function returns 'Key {}'s value has the wrong data type'
    with the brackets filled in with the key value that has the wrong
    data type. The last one tests if the attending being added is
    already in the database, that way there are no duplicates. If the
    attending is already there, the function returns 'Attending is
    already in the database'. If all tests are passed, the function returns
    True.

    Args:
        in_data (json dictionary): contains attending username, attending
            email, and attending phone number; all strings

    Returns:
        string or boolean: string detailing why the input failed or a boolean
            of True if all tests are passed
    """
    if type(in_data) is not dict:
        return "POST data was not a dictionary"
    expected_keys = ["attending_username",
                     "attending_email",
                     "attending_phone"]
    for key in expected_keys:
        if key not in in_data:
            return "Key {} is missing from POST data".format(key)
    expected_types = [str, str, str]
    for key, ex_type in zip(expected_keys, expected_types):
        if type(in_data[key]) is not ex_type:
            return "Key {}'s value has the wrong data type".format(key)
    for att in att_db:
        if att["attending_username"] == in_data["attending_username"]:
            return "Attending is already in the database"
    return True


@app.route('/api/heart_rate/interval_average', methods=['POST'])
def heart_rate_int_avg_handler():
    """Calculating an average heart rate

    The function takes in an input json dictionary from a POST requests
    from a client, calculates an average heart rate using a time stamp
    as an indicator for the number of heart rates to average out, and
    returns the calculated average heart rate and a status code.

    Format of input json dictionary:
    {
        "patient_id": <patient_id>
        "heart_rate_average_since": <time_stamp_string>
    }

    Args:
        (json dictionary): dictionary of patient id and a time stamp string

    Returns:
        json string: calculated average heart rate
        string: status code either 400 for failure or 200 for success
    """
    in_data = request.get_json()
    avg_hr, status_code = internal_avg_hr_worker(in_data)
    return jsonify(avg_hr), status_code


def internal_avg_hr_worker(in_data):
    """Driver function for the route /api/heart_rate/interval_average

    The function validates that the input json dictionary is of
    the correct format, keys, and values, calculates the average heart
    rate, and outputs a message of success or failure when calculating the
    average heart rate and a status code. The function uses two other
    functions: validate_heart_rate_internal_avg and internal_avg_hr.

    Args:
        in_data (json dictionary): contains patient id (str or int) and
            a time stamp (str)

    Returns:
        int: average heart rate
        int: status code of 400 for failure or 200 for success
    """
    result = validate_heart_rate_internal_avg(in_data)
    if result is not True:
        return result, 400
    avg_hr = internal_avg_hr(in_data)
    if type(avg_hr) is str:
        return avg_hr, 400
    return avg_hr, 200


def internal_avg_hr(in_data):
    """Calculates the average heart rate

    The function takes in a json dictionary, converts the time stamp string
    to a datetime object, finds the patient in the database with the
    matching patient id, pulls all the heart rates taken before the inputted
    time stamp, and averages all the heart rates. If the time stamp comes
    before any of the heart rates were taken in the database, the function
    outputs 'There have been no heart rates posted before this time'. The
    function returns the calculated average.

    Args:
        in_data (json dictionary): contains a patient id (str or int) and
            a time stamp (str)

    Returns:
        int or str: average heart rate or an error message detailing there
            were no heart rates before the time stamp
    """
    time_since = datetime.strptime(in_data["heart_rate_average_since"],
                                   '%Y-%m-%d %H:%M:%S')
    hr_since = []
    patient = find_pt(int(in_data['patient_id']))
    for count, time in enumerate(patient['heart_rate_timestamp']):
        if time <= time_since:
            hr_since.append(patient['heart_rate'][count])
    if len(hr_since) == 0:
        return "There have been no heart rates posted before this time"
    avg_hr = sum(hr_since)/len(hr_since)
    return int(avg_hr)


def validate_heart_rate_internal_avg(in_data):
    """Validates the json dictionary

    The function takes in a json dictionary and runs a few tests
    on the values within it. The first one tests if the input is a
    dictionary. If it's not, the function returns 'POST data was not
    a dictionary'. The second one tests if the expected keys are all
    present i.e. patient_id and heart_rate_average_since. If they all
    aren't there, the function returns 'Key {} is missing from POST data'
    with the brackets filled in with the missing key. The third one
    tests if all the key's values are the correct data type. If they
    aren't, the function returns 'Key {}'s value has the wrong data type'
    with the brackets filled in with the key value that has the wrong
    data type. The fourth one tests if the inputted patient id is numeric.
    If it's not, the function returns 'Key patient_id must be an integer
    or numeric string'. The last one tests if the patient with the matching
    patient id is in the database. If it's not, the function returns
    'ID {} not in patient database with the brackets filled in with the
    patient id. If all tests are passed, the function returns True.

    Args:
        in_data (json dictionary): contains patient id (str or int) and
            a time stamp (str)

    Returns:
        str or boolean: a message detailing the error or a boolean of True
    """
    if type(in_data) is not dict:
        return "POST data was not a dictionary"
    expected_keys = ["patient_id",
                     "heart_rate_average_since"]
    for key in expected_keys:
        if key not in in_data:
            return "Key {} is missing from POST data".format(key)
    expected_types = [[str, int], [str]]
    for key, ex_type in zip(expected_keys, expected_types):
        if type(in_data[key]) not in ex_type:
            return "Key {}'s value has the wrong data type".format(key)
    if type(in_data["patient_id"]) == str:
        id_numeric = in_data["patient_id"].isnumeric()
        if not id_numeric:
            return "Key patient_id must be an integer or numeric string"
    if not find_pt(int(in_data["patient_id"])):
        return f"ID {int(in_data['patient_id'])} not in patient database"
    return True


@app.route('/api/status/<patient_id>', methods=['GET'])
def get_pt_status_handler(patient_id):
    """Obtaining heart information of a specific patient

    The function obtains heart information on a particular patient
    in the database. The patient id is specified in the url. The information
    being obtained is the latest heart rate, the status of the patient either
    tachycardic or not tachycardic, and the time stamp of when the latest heart
    rate was taken. The function outputs a json dictionary of the following
    format:
    {
        "heart_rate": <heart_rate_integer>
        "status": <status_string>
        "timestamp": <time_stamp_string>
    }
    The function also outputs the status code.

    Args:
        patient_id (string): the id of the patient

    Returns:
        json dictionary: information of the latest heart rate, time stamp of
            the heart rate, and the status of the patient
        string: status code of either 200 for a suceess or 400 for a failure
    """
    pt_status, status_code = get_pt_status_worker(patient_id)
    return jsonify(pt_status), status_code


def get_pt_status_worker(patient_id):
    """Driver function for the route /api/status/<patient_id>

    The function validates that the input patient id is of
    the correct format, creates an output dictionary, and outputs a
    message of success or failure when creating the output dictionary
    and a status code. The function uses two other
    functions: validate_pt_id and create_status_dict.

    Args:
        patient_id (string): the id of the patient

    Returns:
        json dictionary or string: dictionary of heart information for
            success or a string with an error message
        int: status code of either 200 for success or 400 for failure
    """
    result = validate_pt_id(patient_id)
    if result is not True:
        return result, 400
    pt_status = create_status_dict(patient_id)
    return pt_status, 200


def create_status_dict(patient_id):
    """Creates a dictionary of patient information

    The function takes an input of the patient id, finds the patient in
    the database with the corresponding patient id, pulls out the latest
    heart rate, the latest time stamp, and the status of the patient,
    and returns a dictionary of that information.

    Args:
        patient_id (string): the id of the patient

    Returns:
        dictionary: a dictionary of heart information for a specific patient
    """
    patient = find_pt(int(patient_id))
    latest_time = patient["heart_rate_timestamp"][-1]
    pt_status = {"heart_rate": int(patient["heart_rate"][-1]),
                 "status": str(patient["status"]),
                 "timestamp": latest_time.strftime("%Y-%m-%d %H:%M:%S")}
    return pt_status


@app.route('/api/patients/<attending_username>', methods=['GET'])
def get_pt_att_username_handler(attending_username):
    """Obtains a list of patient information for a given attending

    The function obtains a list of patient information for a given
    attending. The information includes: the patient id, the latest
    heart rate of the patient, the time stamp of that heart rate,
    and the status of the patient either tachycardic or not tachycardic.
    The function outputs a json dictionary of the following
    format:
    {
        "patient_id": <patient_id>
        "last_heart_rate": <heart_rate_integer>
        "last_time": <time_stamp_string>
        "status": <status_string>
    }
    The function also outputs a status code.

    Args:
        attending_username (string): the username of an attending

    Returns:
        list of json dictionary: information of the latest heart rate of
            a patient, the corresponding time stamp, the patient id, and
            the status of the patient
        string: status code of 200 for a success or 400 for a failure
    """
    att_pt_list, status_code = get_pt_att_worker(attending_username)
    return jsonify(att_pt_list), status_code


def get_pt_att_worker(att_username):
    """Driver function for the route /api/patients/<attending_username>

    The function validates that the input attending username is of
    the correct format, creates a list of dictionaries, and outputs a
    message of success or failure when creating the output list
    and a status code. The function uses two other
    functions: validate_attending and create_attending_dict.

    Args:
        att_username (string): the username of the attending

    Returns:
        list of json dictionaries or string: list of dictionaries for
            success or a string with an error message
        int: status code of either 200 for success or 400 for failure
    """
    result = validate_attending(att_username)
    if result is not True:
        return result, 400
    att_pt_list = create_attending_dict(att_username)
    return att_pt_list, 200


def create_attending_dict(att_username):
    """Creates a list of dictionaries of patient information

    The function takes an inputted attending username, loops through the
    patient database, pulls all the patients with the given attending out,
    obtains the latest heart rate, corresponding time stamp, status, and
    patient id for each patient, and puts each dictionary into a list. The
    function returns the list of dictionaries.

    Args:
        att_username (string): the username of the attending

    Returns:
        list of dictionaries: list of dictionaries of patients that have
            the given attending username
    """
    patients_list = []
    for patient in pt_db:
        if patient["attending_username"] == att_username:
            latest_time = patient["heart_rate_timestamp"][-1]
            att_dict = {"patient_id": patient["patient_id"],
                        "last_heart_rate": int(patient["heart_rate"][-1]),
                        "last_time": latest_time.strftime("%Y-%m-%d %H:%M:%S"),
                        "status": patient["status"]}
            patients_list.append(att_dict)
    return patients_list


def validate_attending(att_username):
    """Validates the attending username

    The function takes an inputted attending username and runs
    a series of tests. The first one tests that the attending username
    is of the correct format (LastName.FirstInitial). If it's not,
    the function returns 'Key attending_username have format "LastName.
    FirstInitial"'. The second one tests if the attending is in the
    database. If it's not, the function returns 'Attending {} is not in
    the database with the brackets filled in with the attending username'.
    If all tests are passed, the function returns True.

    Args:
        att_username (string): the username of the attending

    Returns:
        string or boolean: a message detailing the error or a boolean of
            True if all tests are passed
    """
    period_count = att_username.count('.')
    if period_count != 1:
        return 'Key attending_username have format "LastName.FirstInitial"'
    [att_last, att_first] = att_username.split('.')
    if len(att_last) <= 0 or len(att_first) != 1:
        return 'Key attending_username have format "LastName.FirstInitial"'
    if not find_attending(att_username):
        return "Attending {} is not in the database".format(att_username)
    return True


if __name__ == '__main__':
    init_server()
    app.run(host="0.0.0.0")
